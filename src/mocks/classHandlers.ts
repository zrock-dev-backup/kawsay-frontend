import { delay, http, HttpResponse } from "msw";
import { API_BASE_URL } from "../services/api.helpers.ts";
import { db } from "./db.ts";
import type { Class, ClassFormState } from "../interfaces/classDtos.ts";

const CLASS_URL = `${API_BASE_URL}/class`;
const CLASSES_URL = `${API_BASE_URL}/classes`;

export const classHandlers = [
  // GET /classes?timetableId=:id
  http.get(CLASSES_URL, async ({ request }) => {
    const url = new URL(request.url);
    const timetableId = url.searchParams.get("timetableId");

    if (!timetableId) {
      return HttpResponse.json(
        { message: "timetableId is required" },
        { status: 400 },
      );
    }

    const filtered = db.classes.filter(
      (c) => c.timetableId === Number(timetableId),
    );
    await delay(150);
    return HttpResponse.json(filtered);
  }),

  // GET /class/:id
  http.get(`${CLASS_URL}/:id`, async ({ params }) => {
    const classId = Number(params.id);
    const cls = db.classes.find((c) => c.id === classId);

    if (!cls) {
      return new HttpResponse(null, { status: 404 });
    }
    await delay(100);
    return HttpResponse.json(cls);
  }),

  // POST /class
  http.post(CLASS_URL, async ({ request }) => {
    const data = (await request.json()) as ClassFormState;

    const course = db.courses.find((c) => c.id === data.courseId);
    const teacher = db.teachers.find((t) => t.id === data.teacherId);

    if (!course) {
      return HttpResponse.json(
        { message: `Course with ID ${data.courseId} not found.` },
        { status: 400 },
      );
    }

    const newClass: Class = {
      id: db.getNextClassId(),
      timetableId: data.timetableId,
      length: data.length,
      frequency: data.frequency,
      classType: data.classType,
      startDate: data.startDate?.toString() ?? null,
      endDate: data.endDate?.toString() ?? null,
      courseId: data.courseId!,
      courseName: course.name,
      courseCode: course.code,
      teacherId: data.teacherId ?? null,
      teacherName: teacher?.name ?? null,
      classOccurrences: [], // Occurrences are generated by the backend
      periodPreferences: data.periodPreferences,
    };

    db.classes.push(newClass);
    await delay(300);
    return HttpResponse.json(newClass, { status: 201 });
  }),

  // PUT /class/:id
  http.put(`${CLASS_URL}/:id`, async ({ params, request }) => {
    const classId = Number(params.id);
    const data = (await request.json()) as ClassFormState;
    const classIndex = db.classes.findIndex((c) => c.id === classId);

    if (classIndex === -1) {
      return new HttpResponse(null, { status: 404 });
    }

    const course = db.courses.find((c) => c.id === data.courseId);
    const teacher = db.teachers.find((t) => t.id === data.teacherId);

    if (!course) {
      return HttpResponse.json(
        { message: `Course with ID ${data.courseId} not found.` },
        { status: 400 },
      );
    }

    const originalClass = db.classes[classIndex];
    const updatedClass: Class = {
      ...originalClass,
      ...data,
      startDate: data.startDate?.toString() ?? null,
      endDate: data.endDate?.toString() ?? null,
      courseName: course.name,
      courseCode: course.code,
      teacherId: data.teacherId ?? null,
      teacherName: teacher?.name ?? null,
    };

    db.classes[classIndex] = updatedClass;
    await delay(250);
    return HttpResponse.json(updatedClass);
  }),

  // DELETE /class/:id
  http.delete(`${CLASS_URL}/:id`, async ({ params }) => {
    const classId = Number(params.id);
    const initialLength = db.classes.length;
    db.classes = db.classes.filter((c) => c.id !== classId);

    if (db.classes.length === initialLength) {
      // Non-blocking, just log it server-side
      console.warn(`[MSW] Class with id ${classId} not found for deletion.`);
    }

    await delay(200);
    return new HttpResponse(null, { status: 204 });
  }),
];
